#ifndef _FPGA_SIM_H_
#define _FPGA_SIM_H_

#include <stdint.h>
#include "minimap.h"


#define QUERY_NAME_MAXLEN   (252)
#define DP_BATCHSIZE        (128)
#define DP_QUEUE_NUM        (1024)
#define SW_QUEUE_NUM        DP_QUEUE_NUM
#define DP_CTX_NUM          (DP_QUEUE_NUM * DP_BATCHSIZE)
#define SW_CTX_NUM          DP_CTX_NUM
#define SW_LFT_NUM          DP_CTX_NUM
//#define SW_SUBMIT_MEMSIZE   (2^28)//256MB

#define MAX_DP_THRD         (DP_QUEUE_NUM/DP_BATCHSIZE)

#define UNAVAILABLE_ADDR    (0xdeaddeaddeaddead)

typedef enum
{
    GLOBAL_INIT = 0,
    CHAINDP,
    KSW,
    COLLECT_SEED,
} DATA_TYPE_E;



typedef struct {uint64_t x,y;} sim_mm128_t; 


typedef struct
{
    sim_mm128_t *seed;//seed addr @x86
    void *seed_km;//alloc seed km before chaindp
    uint32_t gap_ref;
    uint32_t gap_qry;
    uint32_t seednum;
    int32_t  mid_occ,optflag,qlen_sum;
    uint32_t pos;//context pos@x86 queue
    uint16_t n_segs;
    //mm128_v mv;
    char qname[QUERY_NAME_MAXLEN];
} chaindp_x86_t;


typedef struct
{
    //uint64_t mvn,mvm;
    //uint32_t mvoffset;//from seed[0]
    uint32_t gap_ref;
    uint32_t gap_qry;
    uint32_t seednum;
    int32_t  mid_occ,optflag,qlen_sum;
    uint32_t pos;//context pos@x86 queue
    uint16_t n_segs;
    char qname[QUERY_NAME_MAXLEN];
    sim_mm128_t seed[0];//seed addr @x86
} chaindp_to_fpga_t;


typedef struct
{
    uint32_t offset;
    uint32_t size;
} chaindp_sndsubhdr_t;


typedef struct 
{
    uint32_t size;
    uint16_t tid;//also queue id
    uint16_t num;
    uint8_t  type;
    uint8_t  lat;
    chaindp_sndsubhdr_t subhdr[0];
} chaindp_sndhdr_t;

typedef struct {
    uint32_t offset_kb;
    uint32_t offset_nu;
    uint16_t kb;
    uint16_t nu;
    uint32_t ctxpos;
} chaindp_rcvsubhdr_t ;


typedef struct {
    uint32_t size;
    uint16_t tid;//also queue id
    uint16_t num;
    uint8_t  type;
    uint8_t  pad;
    chaindp_rcvsubhdr_t subhdr[0];
} chaindp_rcvhdr_t ; 

/////////sw

typedef struct 
{
    int16_t qlen;
    int16_t tlen;
    //int32_t qoff;
    //int32_t toff;
    int16_t flag;
    int16_t zdrop,/*zdrop_inv,*/bw;
    int8_t  end_bonus;
    //uint8_t swpos;//one of left,mid,right
} sw_to_fpga_t;


typedef struct
{
    uint32_t offset;//first sw segment, from head always
    uint32_t size;//total ez size of this reg
    uint32_t midnum;//middle cnt in x86
    uint32_t regpos;
    //uint8_t  hasleft;//0 not has, non 0 has
    //uint8_t  hasright;
    uint8_t  pad2;
    uint8_t  pad3;
} sw_reghdr_t;


typedef struct 
{
    uint64_t head;//node list's head
    uint32_t ctxpos;//curr read's ctx position
    uint16_t regnum;//regnum for curr read'sw
    sw_reghdr_t reg;
} sw_readhdr_t;


typedef struct 
{
    uint32_t size;
    uint16_t tid;//thread id
    uint16_t num;//fact readnum
    uint8_t  type;
    uint8_t  lat;//last or not
    sw_readhdr_t data[DP_BATCHSIZE];
} sw_sndhdr_t;



//for test only
typedef struct {
    uint32_t n_a,rep_len,n_mini_pos;
    uint32_t moffset,nuoffset,aoffset;//1offset=4B
    uint32_t subsize,ctxpos;
    int32_t  pvf[0];//pvf+1=move 4B
} dptest_rcvsubhdr_t ;


typedef struct {
    void *   km;
    uint32_t magic;//from dpring magic
    uint32_t size;
    uint16_t tid;
    uint16_t num;
    uint8_t  type;
    uint8_t  lat;
    dptest_rcvsubhdr_t subhdr[0];
} dptest_rcvhdr_t ; 


typedef struct {
    void *   km;
    uint32_t magic;//from swring magic
    uint32_t size;
    uint16_t tid;//threadid
    uint16_t num;
    uint8_t  type;
    uint8_t  lat;
    sw_readhdr_t data[DP_BATCHSIZE];
} swtest_rcvhdr_t ;

static uint32_t merge_to_midnum(uint32_t midnum, int hasleft, int hasright)
{
    uint32_t ret = 0;
    if (hasleft)  ret |= midnum|0x80000000;//set bit 31 to left
    if (hasright) ret |= midnum|0x40000000;//set bit 30 to right
    return ret;
}

static int get_left(uint32_t midnum)
{
    return midnum&0x80000000;//get bit 31
}

static int get_right(uint32_t midnum)
{
    return midnum&0x40000000;//get bit 30
}

static uint32_t clear_midnum(uint32_t midnum)
{
    return midnum&0x3FFFFFFF;//clear bit 31-30
}

//to debug use API,not thread
//#define DEBUG_API

//sim fpga calc
void calc_chaindp_batch(void *addr, void *km, const mm_idx_t *mi, int magic);
int64_t fpgasim_chain_dp(int max_dist_x, int max_dist_y, int bw, int max_skip, int min_cnt, int min_sc, int is_cdna, int n_segs, int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, int32_t *n_v_, int32_t **_v, void *km);
mm128_t *collect_seed_hits(void *km, const mm_mapopt_t *opt, 
                           int max_occ, const mm_idx_t *mi, 
                           const char *qname, const mm128_v *mv, 
                           int qlen, int64_t *n_a, int *rep_len,
                           int *n_mini_pos, uint64_t **mini_pos);

void calc_sw(void *dest, void *km, const void *topt, uint32_t magic);

void debug_kmalloc(void *km, void *addr,int size, char *func, int line);
void debug_kfree(void *km, void *addr,int size, char *func, int line);

#endif//_FPGA_SIM_H_
